
# Web Viewer + Page Source + In-App Dev Console

A lightweight web app that lets you:

* Open any URL inside a wrapper UI
* View the fetched HTML source (when allowed)
* Run JavaScript commands in a sandboxed “console” against the loaded page context

Works as a static site (GitHub Pages) with optional server proxy (Render) for CORS-friendly source fetching.

> **Use responsibly.** Many sites block embedding or source fetching via CORS, CSP, X-Frame-Options, or robots. This tool doesn’t and shouldn’t bypass those controls. Respect site terms.

---

## Features

* **URL Viewer:** Enter a URL and load it in an iframe wrapper with basic navigation.
* **View Source:** Fetch and display the raw HTML source of the target page when CORS and policies allow.
* **Dev Console:** Type JS commands and run them in the iframe via `postMessage` + a tiny injected helper, with output captured and shown inline.
* **One-click Deploy:** Static mode for GitHub Pages, or Render for a server with a simple, safe fetch proxy.
* **No frameworks:** Vanilla HTML/CSS/JS, portable, easy to fork.

---

## How It Works

* **Viewer:** Loads the target URL in a sandboxed `<iframe>` with opt-in flags (`allow-scripts` when you enable the console).
* **Source:** Attempts `fetch(targetURL, { mode: 'cors' })`. If blocked, you’ll see a helpful message. When deployed on Render with the proxy enabled, source is fetched server-side (still honoring the target site’s rules).
* **Console:** Your commands are sent to the iframe via `window.postMessage`. A small injected snippet evaluates safely within that frame and posts results back. If injection is blocked (CSP, sandbox, cross-origin isolation), the console degrades gracefully.

---

## Quick Start

```bash
# Clone
git clone https://github.com/<you>/<repo>.git
cd <repo>

# Local preview (any static server)
python3 -m http.server 8080
# or
npx serve .
```

Open [http://localhost:8080](http://localhost:8080)

---

## File Structure

```
.
├─ public/
│  ├─ index.html          # UI: URL bar, tabs (Viewer | Source | Console)
│  ├─ app.js              # Core logic: load, source fetch, console bridge
│  ├─ styles.css          # Minimal styling
│  └─ icon.svg
├─ server/
│  └─ proxy.js            # Optional fetch proxy for Render (Express)
├─ .env.example           # PROXY_ORIGIN, ALLOWED_HOSTS (Render)
├─ render.yaml            # Render web service config (optional)
└─ README.md
```

---

## Deploy

### Option A: GitHub Pages (static)

1. Push this repo to GitHub.
2. Settings → Pages → Build from branch → `main` → `/root`.
3. Visit your Pages URL.

**Note:** Without the proxy, “View Source” will only work when the target site allows cross-origin fetches. The console also depends on the iframe’s policies set by the target site.

### Option B: Render (with optional proxy)

1. Click “New Web Service,” connect the repo.
2. Root directory: `/`
3. Build command:

   * If proxy only: `npm install --prefix server`
   * If you serve static + proxy: add your static build step, or just serve `/public`.
4. Start command: `node server/proxy.js`
5. Set environment:

   * `PROXY_ORIGIN=https://your-render-app.onrender.com`
   * `ALLOWED_HOSTS=example.com,developer.mozilla.org`
     Comma-separated allowlist the proxy will fetch from.

**render.yaml (example):**

```yaml
services:
  - type: web
    name: web-viewer-console
    env: node
    plan: free
    buildCommand: "npm install --prefix server"
    startCommand: "node server/proxy.js"
    envVars:
      - key: PROXY_ORIGIN
        value: https://your-render-app.onrender.com
      - key: ALLOWED_HOSTS
        value: example.com,developer.mozilla.org
```

---

## Minimal Code Snippets

### `public/index.html`

```html
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Web Viewer + Source + Console</title>
  <link rel="stylesheet" href="./styles.css" />
</head>
<body>
  <header>
    <input id="urlInput" type="url" placeholder="https://example.com" />
    <button id="loadBtn">Load</button>
    <label><input id="enableScripts" type="checkbox" /> enable console scripts</label>
  </header>

  <nav class="tabs">
    <button data-tab="viewer" class="active">Viewer</button>
    <button data-tab="source">Source</button>
    <button data-tab="console">Console</button>
  </nav>

  <section id="viewer" class="tab active">
    <iframe id="frame" sandbox="allow-same-origin" referrerpolicy="no-referrer"></iframe>
  </section>

  <section id="source" class="tab">
    <pre id="sourcePre">Load a URL to fetch its HTML...</pre>
  </section>

  <section id="console" class="tab">
    <div id="consoleOut" aria-live="polite"></div>
    <form id="consoleForm">
      <input id="consoleIn" placeholder="document.title" autocomplete="off" />
      <button>Run</button>
    </form>
  </section>

  <script src="./app.js"></script>
</body>
</html>
```

### `public/app.js` (core ideas, trimmed)

```js
const urlInput = document.getElementById('urlInput');
const loadBtn = document.getElementById('loadBtn');
const frame = document.getElementById('frame');
const enableScripts = document.getElementById('enableScripts');

const sourcePre = document.getElementById('sourcePre');
const consoleForm = document.getElementById('consoleForm');
const consoleIn = document.getElementById('consoleIn');
const consoleOut = document.getElementById('consoleOut');

const PROXY = (window.PROXY_ORIGIN || ''); // set at build or inject via script

// Tab UI
document.querySelectorAll('.tabs button').forEach(b=>{
  b.addEventListener('click', ()=>{
    document.querySelectorAll('.tabs button').forEach(x=>x.classList.remove('active'));
    document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    document.getElementById(b.dataset.tab).classList.add('active');
  });
});

loadBtn.addEventListener('click', async ()=>{
  const target = urlInput.value.trim();
  if (!target) return;

  // Adjust iframe sandbox
  frame.setAttribute('sandbox', enableScripts.checked ? 'allow-scripts allow-same-origin' : 'allow-same-origin');
  frame.src = target;

  // Try source fetch
  sourcePre.textContent = 'Fetching...';
  try {
    const src = await fetchSource(target);
    sourcePre.textContent = src;
  } catch (e) {
    sourcePre.textContent = String(e?.message || e);
  }
});

// Fetch source (direct or via proxy)
async function fetchSource(target) {
  try {
    const res = await fetch(target, { mode: 'cors' });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.text();
  } catch (e) {
    if (!PROXY) throw new Error('CORS blocked and no proxy configured.');
    const u = new URL('/proxy', PROXY);
    u.searchParams.set('url', target);
    const res = await fetch(u.toString());
    if (!res.ok) throw new Error(`Proxy HTTP ${res.status}`);
    return await res.text();
  }
}

// Console bridge
window.addEventListener('message', evt=>{
  if (evt.data && evt.data.type === 'console:result') {
    const div = document.createElement('div');
    div.textContent = `→ ${evt.data.ok ? 'OK' : 'ERR'}: ${evt.data.value}`;
    consoleOut.prepend(div);
  }
});

consoleForm.addEventListener('submit', (e)=>{
  e.preventDefault();
  const code = consoleIn.value;
  if (!code) return;
  frame.contentWindow?.postMessage({ type: 'console:eval', code }, '*');
  consoleIn.value = '';
});

// Attempt to inject a helper when frame loads
frame.addEventListener('load', ()=>{
  try {
    frame.contentWindow.postMessage({ type: 'console:inject' }, '*');
  } catch {}
});
```

### Injected helper (runs inside the iframe if policies allow)

```js
// Put this in a small <script> the parent attempts to inject, or inline on same-origin demos.
(function(){
  if (window.__consoleBridge) return;
  window.__consoleBridge = true;

  window.addEventListener('message', async (evt)=>{
    const { type, code } = evt.data || {};
    if (type === 'console:inject') {
      evt.source.postMessage({ type: 'console:result', ok: true, value: 'bridge-ready' }, '*');
    }
    if (type === 'console:eval') {
      try {
        const result = await (0, eval)(code); // evaluates in frame context
        evt.source.postMessage({ type: 'console:result', ok: true, value: String(result) }, '*');
      } catch (err) {
        evt.source.postMessage({ type: 'console:result', ok: false, value: String(err) }, '*');
      }
    }
  });
})();
```

### `server/proxy.js` (Render optional)

```js
const express = require('express');
const fetch = (...args) => import('node-fetch').then(({default: f}) => f(...args));
const app = express();

const ALLOWED = new Set((process.env.ALLOWED_HOSTS || '').split(',').map(s=>s.trim()).filter(Boolean));

app.get('/proxy', async (req, res) => {
  try {
    const url = new URL(req.query.url);
    if (!ALLOWED.size || !ALLOWED.has(url.hostname)) {
      return res.status(403).send('Host not allowed');
    }
    const upstream = await fetch(url.toString(), { redirect: 'follow' });
    res.status(upstream.status);
    res.set('Content-Type', upstream.headers.get('content-type') || 'text/plain');
    res.send(await upstream.text());
  } catch (e) {
    res.status(400).send(String(e?.message || e));
  }
});

const port = process.env.PORT || 10000;
app.listen(port, ()=>console.log(`Proxy listening on ${port}`));
```

---

## Environment

Copy `.env.example` to `.env` (Render only):

```
PROXY_ORIGIN=https://your-render-app.onrender.com
ALLOWED_HOSTS=example.com,developer.mozilla.org
```

---

## Security & Limitations

* **No bypassing site protections.** If a site sets CSP, X-Frame-Options, or blocks cross-origin fetches, the app will respect that. That’s the point.
* **Console scope is limited.** Code runs in the iframe only if the site’s policies permit message handling and script execution.
* **Privacy.** The proxy does not store content. It simply forwards responses. Audit and harden before production use.
* **Allowlist only.** The proxy fetches domains you explicitly allow via `ALLOWED_HOSTS`.

---

## Keyboard Shortcuts

* `Ctrl/⌘ + Enter` in the console input: run command
* `Ctrl/⌘ + L` focuses the URL bar

---

## FAQ

**Why does the page not load in the viewer?**
Likely blocked by `X-Frame-Options` or CSP. Nothing to “fix” here.

**Why can’t I view source for some URLs?**
CORS blocks direct fetch. Use the Render proxy and add the domain to `ALLOWED_HOSTS`. If the origin actively forbids it, accept reality.

**Why don’t console commands work?**
The target page’s policies may prevent injection or messaging. Try another site or your own test page.

---

## License

MIT. Use at your own risk.

---

## Credits

Built with plain HTML/CSS/JS. Optional proxy with Express. No client frameworks.

